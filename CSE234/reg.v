//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module MULTI_REG(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,
	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);

	wire [4:0]loadout;

	parallelLoad(CLOCK_50, loadBTN, LEDR[4:0], loadout);
	//multifunctionReg(CLOCK_50, ~KEY[2:0], LEDR[4:0], loadout);

	wire [4:0]zero;
	wire [4:0]one;
	wire [4:0]two;
	wire [4:0]three;
	wire [4:0]muxout;

	assign zero = loadout;
	adder(SW[9:5], loadout, one);
	myxor(SW[9:5], loadout, two);
	realSwitch(SW[9:5], CLOCK_50,SW[2] ,two);
	assign three = SW[9:5];

	_4_1_mux(zero,one,two,three, SW[1], SW[0], muxout);

	assign LEDR[4:0] = muxout;

endmodule

module realSwitch(input [4:0] in, input clk, btn, output reg[4:0] out);

	wire [4:0] tmp;

	_1_2_mux_sel(in[4], 0, btn, tmp[4]);
	_1_2_mux_sel(in[3], tmp[4], btn, tmp[3]);
	_1_2_mux_sel(in[2], tmp[3], btn, tmp[2]);
	_1_2_mux_sel(in[1], tmp[2], btn, tmp[1]);
	_1_2_mux_sel(in[0], tmp[1], btn, tmp[0]);

	always @(posedge clk)
	begin
		out <= tmp;
	end

endmodule

module _1_2_mux_sel(input a, b, sel, output out);
	assign out = (sel) ? b : a;
endmodule


module parallelLoad(input clk, btn, input [4:0] led, output [4:0]out);

	wire [4:0]tmp;
	reg [4:0]register;

	assign tmp = (btn) ? led : out; // mux

	always @(posedge clk)
	begin
		register <= tmp;
	end

	assign out = register;

endmodule


module multifunctionReg(input clk, input [2:0]btns, input [4:0] led, output [4:0] out);

	wire [4:0]tmp;

	reg [4:0] register;

	/*
		0 --> clear
		1 --> load
		2 --> shiftR
		3 --> shiftL
		4 --> set
		5 --> maintain
		6 --> reverse
		7 --> incement
	*/

	wire [4:0] shiftR;
	wire [4:0] shiftL;
	wire [4:0] reverse;
	wire [4:0] incement;

	_5_bit_shiftRight(led, shiftR);
	_5_bit_shiftLeft(led, shiftL);
	_5_bit_reverse(led, reverse);
	_5_bit_increment(led, incement);

	assign tmp =	(btns == 3'b000) ? 3'b000 :
						(btns == 3'b001) ? led :
						(btns == 3'b010) ? shiftR :
						(btns == 3'b011) ? shiftL :
						(btns == 3'b100) ? 3'b111 :
						(btns == 3'b101) ? out :
						(btns == 3'b110) ? reverse : incement;

	always @(posedge clk)
	begin
		register <= tmp;
	end

	assign out = register;
endmodule

module _5_bit_increment(input [4:0]led, output [4:0]out);
	assign out = led + 5'b1;
endmodule

module _5_bit_reverse(input [4:0]led, output [4:0]out);
	assign out[0] = led[4];
	assign out[1] = led[3];
	assign out[2] = led[2];
	assign out[3] = led[1];
	assign out[4] = led[0];
endmodule

module _5_bit_shiftRight(input [4:0]led, output [4:0]out);
	assign out[4] = 0;
	assign out[3] = led[4];
	assign out[2] = led[3];
	assign out[1] = led[2];
	assign out[0] = led[1];
endmodule

module _5_bit_shiftLeft(input [4:0]led, output [4:0]out);
	assign out[0] = 0;
	assign out[1] = led[0];
	assign out[2] = led[1];
	assign out[3] = led[2];
	assign out[4] = led[3];
endmodule

module adder(input [4:0]a, b, output [4:0] out);
	assign out = a + b;
endmodule

module myxor(input [4:0]a, b, output [4:0] out);
	assign out = a ^ b;
endmodule

module _4_1_mux(input [4:0]a,b,c,d, input sw1, sw0, output [4:0]out);
	assign out = (sw1) ? ((sw0) ? d : c) : ((sw0) ? b : a);
endmodule
